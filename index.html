<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bounded Spiral Playground</title>
  <script src="https://cdn.plot.ly/plotly-2.24.2.min.js"></script>
  <style>
    :root{--bg:#0d0d0d;--surface:#161616;--accent:#0a84ff;--text:#eaeaea;--muted:#888;--grid:#222}
    *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif}
    body{margin:0;display:flex;flex-direction:column;min-height:100vh;background:var(--bg);color:var(--text)}
    header{padding:1.2rem 2rem;font-size:1.4rem;font-weight:600}
    main{flex:1;display:grid;grid-template-rows:1fr auto}
    #graph{width:100%;height:100%}
    #controls{background:var(--surface);padding:1rem 2rem;border-top:1px solid #222;display:flex;flex-wrap:wrap;gap:1.4rem 2.5rem;justify-content:center}
    .control{display:flex;flex-direction:column;gap:.35rem;width:240px}
    label{font-size:.9rem;font-weight:500;color:var(--muted)}
    input[type=range]{-webkit-appearance:none;width:100%;height:6px;border-radius:3px;background:#333}
    input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;border-radius:50%;background:var(--accent);cursor:pointer;transition:transform .15s ease}
    input[type=range]::-webkit-slider-thumb:active{transform:scale(1.25)}
    .value-label{align-self:flex-end;font-size:.85rem}
    button{padding:.6rem 1rem;border:none;border-radius:6px;background:var(--accent);color:#fff;cursor:pointer;font-size:.9rem;margin-top:.6rem}
  </style>
</head>
<body>
  <header>Bounded Spiral Designer</header>
  <main>
    <section id="graph"></section>
    <section id="controls">
      <div class="control"><label for="slices">Slices (360°/value)</label><input type="range" id="slices" min="1" max="10" value="6" step="1"><span class="value-label" id="sliceVal">6</span></div>
      <div class="control"><label for="bounces">Outward bounces (N)</label><input type="range" id="bounces" min="1" max="30" value="6" step="1"><span class="value-label" id="bounceVal">6</span></div>
      <div class="control"><label for="r0">Start radius r₀ (ft)</label><input type="range" id="r0" min="0.1" max="30" value="1" step="0.1"><span class="value-label" id="r0Val">1 ft</span></div>
      <div class="control"><label for="rHold">Hold radius r<sub>hold</sub> (ft)</label><input type="range" id="rHold" min="2" max="200" value="50" step="1"><span class="value-label" id="rHoldVal">50 ft</span></div>
      <button id="exportBtn">Console Waypoints</button>
    </section>
  </main>

<script>(()=>{
  /* -------- helpers -------- */
  const $=id=>document.getElementById(id);
  const sliceS=$('slices'), nS=$('bounces'), r0S=$('r0'), rhS=$('rHold');
  const lbl={sliceVal:$('sliceVal'),bounceVal:$('bounceVal'),r0Val:$('r0Val'),rHoldVal:$('rHoldVal')};
  [sliceS,nS,r0S,rhS].forEach(s=>s.addEventListener('input',refresh));
  $('exportBtn').addEventListener('click',()=>console.log(JSON.stringify(generateWaypoints(),null,2)));

  const toRad=d=>d*Math.PI/180;
  const params=_=>({ slices:+sliceS.value, N:+nS.value, r0:+r0S.value, rHold:+rhS.value });
  const labels=_=>{lbl.sliceVal.textContent=sliceS.value;lbl.bounceVal.textContent=nS.value;lbl.r0Val.textContent=`${r0S.value} ft`;lbl.rHoldVal.textContent=`${rhS.value} ft`;};

  /* -------- spiral math -------- */
  function baseSpiral({dphi,N,r0,rHold,steps=800}){
    const alpha=Math.log(rHold/r0)/(N*dphi);
    const tOut=N*dphi,tHold=dphi,tTot=2*tOut+tHold;
    const theta=Array.from({length:steps},(_,i)=>i*tTot/(steps-1));
    const r=theta.map(th=>th<=tOut?r0*Math.exp(alpha*th):th<=tOut+tHold?rHold:r0*Math.exp(alpha*(tTot-th)));
    const phi=theta.map(th=>{const ph=((th/dphi)%2+2)%2;return ph<=1?ph*dphi:(2-ph)*dphi;});
    const x=r.map((ri,i)=>ri*Math.cos(phi[i]));
    const y=r.map((ri,i)=>ri*Math.sin(phi[i]));
    return{theta,r,phi,x,y};
  }

  /* -------- fit exponential arc with circular fillet(s) -------- */
  const MAX_ERR=0.2; // ft
  function dist(p,q){return Math.hypot(p.x-q.x,p.y-q.y);}  
  function circleFrom3(a,b,c){ // returns {center:{x,y},R}
    const d=2*(a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y));
    if(Math.abs(d)<1e-6) return null; // colinear
    const ux=((a.x*a.x+a.y*a.y)*(b.y-c.y)+(b.x*b.x+b.y*b.y)*(c.y-a.y)+(c.x*c.x+c.y*c.y)*(a.y-b.y))/d;
    const uy=((a.x*a.x+a.y*a.y)*(c.x-b.x)+(b.x*b.x+b.y*b.y)*(a.x-c.x)+(c.x*c.x+c.y*c.y)*(b.x-a.x))/d;
    const R=Math.hypot(a.x-ux,a.y-uy);
    return{center:{x:ux,y:uy},R};
  }
  function arcDeviation(points,circle){ // coarse max dev against circle arc
    return points.reduce((m,p)=>Math.max(m,Math.abs(Math.hypot(p.x-circle.center.x,p.y-circle.center.y)-circle.R)),0);
  }
  function fitArc(phi0,phi1,spiral,dphi,r){
    // compute start, mid, end points along exponential
    const midPhi=(phi0+phi1)/2;
    const expPt=phi=>({x:r*Math.exp(alpha*(phi-phi0))*Math.cos(phi),y:r*Math.exp(alpha*(phi-phi0))*Math.sin(phi)});
  }
  // Simpler approach: sample dense points, pick every boundary index and midpoint, compute circle, test err, else split once.
  function buildWaypointsSlice(sliceIdx,p){
    const offset=Math.PI/2; // rotate north
    const dphi=(2*Math.PI)/p.slices;
    const base=baseSpiral({...p,dphi,steps:1200});
    // find indices where phi==0 or phi==dphi (boundaries)
    const bIdx=[0];
    for(let i=1;i<base.phi.length;i++){
      if(Math.abs(base.phi[i])<1e-4||Math.abs(base.phi[i]-dphi)<1e-4) bIdx.push(i);
    }
    if(bIdx[bIdx.length-1]!==base.phi.length-1) bIdx.push(base.phi.length-1);

    const waypoints=[];
    for(let s=0;s<bIdx.length-1;s++){
      const i0=bIdx[s], i1=bIdx[s+1];
      const start={x:base.x[i0],y:base.y[i0]}, end={x:base.x[i1],y:base.y[i1]};
      // midpoint index
      const im=Math.floor((i0+i1)/2);
      const mid={x:base.x[im],y:base.y[im]};
      let circle=circleFrom3(start,mid,end);
      let pts=base.x.slice(i0,i1+1).map((_,j)=>({x:base.x[i0+j],y:base.y[i0+j]}));
      if(!circle||arcDeviation(pts,circle)>MAX_ERR){
        // split into two arcs
        const im1=Math.floor((i0+im)/2), im2=Math.floor((im+i1)/2);
        const mid1={x:base.x[im1],y:base.y[im1]}, mid2={x:base.x[im2],y:base.y[im2]};
        const c1=circleFrom3(start,mid1,mid);
        const c2=circleFrom3(mid,end,mid2);
        const curve1=c1?c1.R:0, curve2=c2?c2.R:0;
        waypoints.push({...rot(start,offset+sliceIdx*dphi),curve:0});
        waypoints.push({...rot(mid1,offset+sliceIdx*dphi),curve:curve1});
        waypoints.push({...rot(mid,offset+sliceIdx*dphi),curve:curve1});
        waypoints.push({...rot(mid2,offset+sliceIdx*dphi),curve:curve2});
        if(s===bIdx.length-2) waypoints.push({...rot(end,offset+sliceIdx*dphi),curve:0});
      }else{
        const curve=circle.R;
        waypoints.push({...rot(start,offset+sliceIdx*dphi),curve:0});
        waypoints.push({...rot(mid,offset+sliceIdx*dphi),curve:curve});
        if(s===bIdx.length-2) waypoints.push({...rot(end,offset+sliceIdx*dphi),curve:0});
      }
    }
    return waypoints;
    function rot(pt,ang){return{x:pt.x*Math.cos(ang)-pt.y*Math.sin(ang),y:pt.x*Math.sin(ang)+pt.y*Math.cos(ang)}}
  }
  function generateWaypoints(){
    const p=params();
    const all=[];
    for(let k=0;k<p.slices;k++){
      all.push(buildWaypointsSlice(k,p));
    }
    return all; // array of slices each slice array of waypoints {x,y,curve}
  }

  /* ---------- draw & refresh ---------- */
  function draw(){
    const p=params();
    const dphi=(2*Math.PI)/p.slices;
    const base=baseSpiral({...p,dphi,steps:1500});
    const traces=[];
    const hueStart=220, hueEnd=300;
    const offset=Math.PI/2;
    for(let k=0;k<p.slices;k++){
      const ang=offset+k*dphi, c=Math.cos(ang), s=Math.sin(ang);
      const rx=base.x.map((x,i)=>x*c-base.y[i]*s), ry=base.x.map((x,i)=>x*s+base.y[i]*c);
      const hue=hueStart+(hueEnd-hueStart)*(k/(p.slices-1||1));
      traces.push({x:rx,y:ry,mode:'lines',line:{color:`hsl(${hue} 80% 55%)`,width:2},hoverinfo:'skip'});
      traces.push({x:[0,p.rHold*Math.cos(ang)],y:[0,p.rHold*Math.sin(ang)],mode:'lines',line:{color:'#ff9500',width:2,dash:'dot'},hoverinfo:'skip'});
    }
    Plotly.react('graph',traces,{margin:{t:20,l:20,r:20,b:20},paper_bgcolor:'var(--bg)',plot_bgcolor:'var(--bg)',xaxis:{showgrid:true,gridcolor:'var(--grid)',dtick:2,zeroline:false,showticklabels:false,scaleanchor:'y',scaleratio:1},yaxis:{showgrid:true,gridcolor:'var(--grid)',dtick:2,zeroline:false,showticklabels:false}});
  }
  function refresh(){labels();draw();}
  labels();draw();
})();</script>
</body>
</html>
