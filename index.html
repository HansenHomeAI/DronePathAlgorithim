<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bounded Spiral Designer</title>
  <script src="https://cdn.plot.ly/plotly-2.24.2.min.js"></script>
  <style>
    :root{--bg:#0d0d0d;--surface:#161616;--accent:#0a84ff;--text:#eaeaea;--muted:#888;--grid:#222}
    *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif}
    body{margin:0;min-height:100vh;display:flex;flex-direction:column;background:var(--bg);color:var(--text)}
    header{padding:1.2rem 2rem;font-size:1.4rem;font-weight:600}
    main{flex:1;display:grid;grid-template-rows:1fr auto}
    #graph{width:100%;height:100%}
    #controls{background:var(--surface);padding:1rem 2rem;border-top:1px solid #222;display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:1.2rem 2rem}
    .control{display:flex;flex-direction:column;gap:.35rem}
    label{font-size:.9rem;font-weight:500;color:var(--muted)}
    input[type=range],input[type=text]{width:100%;}
    input[type=range]{-webkit-appearance:none;height:6px;border-radius:3px;background:#333}
    input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;border-radius:50%;background:var(--accent);cursor:pointer}
    input[type=text]{padding:.45rem .6rem;border-radius:6px;border:1px solid #333;background:#0f0f0f;color:var(--text)}
    .value-label{align-self:flex-end;font-size:.85rem}
    button{padding:.55rem 1.1rem;border:none;border-radius:6px;background:var(--accent);color:#fff;cursor:pointer;font-size:.85rem}
    #btnRow{grid-column:1/-1;display:flex;gap:1rem;justify-content:center}
  </style>
</head>
<body>
  <header>Bounded Spiral Designer</header>
  <main>
    <section id="graph"></section>
    <section id="controls">
      <div class="control"><label>Slices (360° / value)</label><input id="slices" type="range" min="1" max="10" value="6"><span class="value-label" id="sliceVal">6</span></div>
      <div class="control"><label>Outward bounces (N)</label><input id="bounces" type="range" min="1" max="30" value="6"><span class="value-label" id="bounceVal">6</span></div>
      <div class="control"><label>Start radius r₀ (ft)</label><input id="r0" type="range" min="0.1" max="30" value="1" step="0.1"><span class="value-label" id="r0Val">1 ft</span></div>
      <div class="control"><label>Hold radius r<sub>hold</sub> (ft)</label><input id="rHold" type="range" min="2" max="200" value="50" step="1"><span class="value-label" id="rHoldVal">50 ft</span></div>
      <div class="control" style="grid-column:1/-1"><label>Center (lat, lon)</label><input id="centerLL" type="text" placeholder="41.73218° N, 111.83979° W  or  41.73218, -111.83979"></div>
      <div id="btnRow"><button id="consoleBtn">Console Waypoints</button><button id="csvBtn">Download CSV</button></div>
    </section>
  </main>

<script>
(()=>{
  const $=id=>document.getElementById(id);
  const sliceS=$('slices'), nS=$('bounces'), r0S=$('r0'), rhS=$('rHold');
  const lbl={sliceVal:$('sliceVal'),bounceVal:$('bounceVal'),r0Val:$('r0Val'),rHoldVal:$('rHoldVal')};
  [sliceS,nS,r0S,rhS].forEach(el=>el.addEventListener('input',()=>refresh(false)));
  $('consoleBtn').addEventListener('click',()=>{computeWaypoints();console.log(JSON.stringify(waypointCache,null,2));draw(true);} );
  $('csvBtn').addEventListener('click',downloadCSV);

  const MAX_ERR=0.2, EARTH_R=6378137, FT2M=0.3048;

  const dist=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
  const circle3=(A,B,C)=>{const d=2*(A.x*(B.y-C.y)+B.x*(C.y-A.y)+C.x*(A.y-B.y));if(Math.abs(d)<1e-6) return null;const ux=((A.x*A.x+A.y*A.y)*(B.y-C.y)+(B.x*B.x+B.y*B.y)*(C.y-A.y)+(C.x*C.x+C.y*C.y)*(A.y-B.y))/d;const uy=((A.x*A.x+A.y*A.y)*(C.x-B.x)+(B.x*B.x+B.y*B.y)*(A.x-C.x)+(C.x*C.x+C.y*C.y)*(B.x-A.x))/d;return{c:{x:ux,y:uy},R:dist(A,{x:ux,y:uy})};};
  const maxErr=(pts,c)=>pts.reduce((m,p)=>Math.max(m,Math.abs(dist(p,c.c)-c.R)),0);
  const rot=(p,a)=>({x:p.x*Math.cos(a)-p.y*Math.sin(a),y:p.x*Math.sin(a)+p.y*Math.cos(a)});

  const params=()=>({slices:+sliceS.value,N:+nS.value,r0:+r0S.value,rHold:+rhS.value});
  const updateLabels=()=>{lbl.sliceVal.textContent=sliceS.value;lbl.bounceVal.textContent=nS.value;lbl.r0Val.textContent=`${r0S.value} ft`;lbl.rHoldVal.textContent=`${rhS.value} ft`;};

  function makeSpiral({dphi,N,r0,rHold,steps=1200}){
    const alpha=Math.log(rHold/r0)/(N*dphi);
    const tOut=N*dphi,tHold=dphi,tTot=2*tOut+tHold;
    return Array.from({length:steps},(_,i)=>{
      const th=i*tTot/(steps-1);
      const r=th<=tOut?r0*Math.exp(alpha*th):th<=tOut+tHold?rHold:r0*Math.exp(alpha*(tTot-th));
      const phase=((th/dphi)%2+2)%2; const phi=phase<=1?phase*dphi:(2-phase)*dphi;
      return{x:r*Math.cos(phi),y:r*Math.sin(phi)};});
  }

  let waypointCache=[];
  function buildSlice(idx,p){
    const dphi=2*Math.PI/p.slices, off=Math.PI/2+idx*dphi;
    const pts=makeSpiral({...p,dphi});
    const stepAng=dphi/(pts.length-1);
    const bounds=[0];for(let i=1;i<pts.length;i++){const ang=i*stepAng%dphi;if(ang<1e-3||Math.abs(ang-dphi)<1e-3) bounds.push(i);}if(bounds[bounds.length-1]!==pts.length-1) bounds.push(pts.length-1);
    const out=[];
    for(let s=0;s<bounds.length-1;s++){
      const i0=bounds[s],i1=bounds[s+1],im=Math.floor((i0+i1)/2),A=pts[i0],B=pts[im],C=pts[i1],seg=pts.slice(i0,i1+1);let circ=circle3(A,B,C);
      const push=(pt,c)=>out.push({...rot(pt,off),curve:+c.toFixed(2)});
      if(!circ||maxErr(seg,circ)>MAX_ERR){const im1=Math.floor((i0+im)/2),im2=Math.floor((im+i1)/2);const B1=pts[im1],B2=pts[im2];const c1=circle3(A,B1,B),c2=circle3(B,B2,C);push(A,0);if(c1)push(B1,c1.R);push(B,c1?c1.R:0);if(c2)push(B2,c2.R);if(s===bounds.length-2)push(C,0);}else{push(A,0);push(B,circ.R);if(s===bounds.length-2)push(C,0);} }
    return out;
  }
  function computeWaypoints(){ waypointCache.length=0; const p=params(); for(let i=0;i<p.slices;i++) waypointCache.push(buildSlice(i,p)); }

  function draw(showWP=false){
    const p=params(); const dphi=2*Math.PI/p.slices, raw=makeSpiral({...p,dphi}); const traces=[]; const hue0=220,hue1=300,off=Math.PI/2;
    for(let k=0;k<p.slices;k++){const ang=off+k*dphi,c=Math.cos(ang),s=Math.sin(ang);traces.push({x:raw.map(pt=>pt.x*c-pt.y*s),y:raw.map(pt=>pt.x*s+pt.y*c),mode:'lines',line:{color:`hsl(${hue0+(hue1-hue0)*(k/(p.slices-1||1))} 80% 55%)`,width:2}});traces.push({x:[0,p.rHold*Math.cos(ang)],y:[0,p.rHold*Math.sin(ang)],mode:'lines',line:{color:'#ff9500',width:2,dash:'dot'}});} if(showWP){ waypointCache.forEach((slice,k)=>{const hue=hue0+(hue1-hue0)*(k/(p.slices-1||1));traces.push({x:slice.map(w=>w.x),y:slice.map(w=>w.y),mode:'markers',marker:{color:`hsl(${hue} 80% 55%)`,size:4}});}); }
    Plotly.newPlot('graph',traces,{margin:{t:20,l:20,r:20,b:20},paper_bgcolor:'var(--bg)',plot_bgcolor:'var(--bg)',xaxis:{showgrid:true,gridcolor:'var(--grid)',dtick:2,showticklabels:false,zeroline:false,scaleanchor:'y',scaleratio:1},yaxis:{showgrid:true,gridcolor:'var(--grid)',dtick:2,showticklabels:false,zeroline:false}});
  }

  function refresh(drawWP){ draw(drawWP); waypointCache.length=0; updateLabels(); }

  function downloadCSV(){ 
    const center = parseCenter($("centerLL").value.trim()); 
    if(!center) {
      alert('Enter center lat,lon');
      return;
    }
    
    // Generate a single continuous spiral path instead of separate slices
    const p = params();
    const spiralPath = generateContinuousSpiral(p);
    
    // Litchi mission format header
    const header = "latitude,longitude,altitude(ft),heading(deg),curvesize(ft),rotationdir,gimbalmode,gimbalpitchangle,altitudemode,speed(m/s),poi_latitude,poi_longitude,poi_altitude(ft),poi_altitudemode,photo_timeinterval,photo_distinterval";
    const rows = [header];
    
    // Generate optimized waypoints with curves
    spiralPath.forEach((wp, i) => {
      const {lat, lon} = xy2ll(wp.x, wp.y, center.lat, center.lon);
      
      // Round coordinates to proper precision
      const latitude = Math.round(lat * 100000) / 100000;
      const longitude = Math.round(lon * 100000) / 100000;
      
      // Calculate altitude based on distance from center
      const distFromCenter = Math.sqrt(wp.x * wp.x + wp.y * wp.y);
      const baseAltitude = 70;
      const altitude = Math.round((baseAltitude + (distFromCenter * 0.8)) * 100) / 100;
      
      // Calculate heading to next waypoint
      let heading = 0;
      if (i < spiralPath.length - 1) {
        const next = spiralPath[i + 1];
        const dx = next.x - wp.x;
        const dy = next.y - wp.y;
        heading = Math.round(((Math.atan2(dx, dy) * 180 / Math.PI) + 360) % 360);
      }
      
      // Use curve radius from spiral calculation
      const curveSizeMeters = Math.round((wp.curve * FT2M) * 100) / 100;
      
      // Calculate gimbal pitch
      const gimbalPitch = Math.round(-10 - (altitude - baseAltitude) * 0.1);
      
      // Create waypoint row
      const row = [
        latitude,
        longitude,  
        altitude,
        heading,
        curveSizeMeters,
        0,                          // rotationdir
        2,                          // gimbalmode (focus POI)
        gimbalPitch,                // gimbalpitchangle
        0,                          // altitudemode
        8.85,                       // speed(m/s)
        center.lat,                 // poi_latitude
        center.lon,                 // poi_longitude  
        0,                          // poi_altitude
        0,                          // poi_altitudemode
        i === 0 ? 0 : 2.8,         // photo_timeinterval
        0                           // photo_distinterval
      ].join(',');
      
      rows.push(row);
    });
    
    // Create and download the file
    const blob = new Blob([rows.join('\n')], {type: 'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `litchi_spiral_mission.csv`;
    a.click();
    URL.revokeObjectURL(a.href);
  }

  // Generate a single continuous spiral that matches the visual design
  function generateContinuousSpiral(params) {
    const { slices, N, r0, rHold } = params;
    const waypoints = [];
    
    // Create one continuous spiral that covers all slices
    const totalSteps = 120; // Reduced for efficiency
    const dphi = 2 * Math.PI / slices;
    const alpha = Math.log(rHold / r0) / (N * dphi);
    const tOut = N * dphi;
    const tHold = dphi;
    const tTotal = 2 * tOut + tHold;
    
    // Generate spiral points with proper curve calculations
    for (let i = 0; i < totalSteps; i++) {
      const t = i * tTotal / (totalSteps - 1);
      
      // Calculate radius based on spiral phase
      let r;
      if (t <= tOut) {
        // Outward spiral
        r = r0 * Math.exp(alpha * t);
      } else if (t <= tOut + tHold) {
        // Hold pattern
        r = rHold;
      } else {
        // Inward spiral
        r = r0 * Math.exp(alpha * (tTotal - t));
      }
      
      // Calculate angle for continuous spiral
      const angle = t * slices; // This creates the multi-slice coverage
      
      // Convert to cartesian coordinates
      const x = r * Math.cos(angle);
      const y = r * Math.sin(angle);
      
      // Calculate curve radius for smooth flight
      let curve = 0;
      if (i > 0 && i < totalSteps - 1) {
        // Estimate curve radius based on rate of direction change
        const prevT = (i - 1) * tTotal / (totalSteps - 1);
        const nextT = (i + 1) * tTotal / (totalSteps - 1);
        
        const prevAngle = prevT * slices;
        const nextAngle = nextT * slices;
        
        const prevX = r * Math.cos(prevAngle);
        const prevY = r * Math.sin(prevAngle);
        const nextX = r * Math.cos(nextAngle);
        const nextY = r * Math.sin(nextAngle);
        
        // Calculate curve radius using circumcircle
        const A = { x: prevX, y: prevY };
        const B = { x, y };
        const C = { x: nextX, y: nextY };
        
        const circ = circle3(A, B, C);
        if (circ && circ.R > 0.1 && circ.R < 1000) {
          curve = circ.R;
        }
      }
      
      waypoints.push({ x, y, curve });
    }
    
    return waypoints;
  }

  function parseCenter(txt){
    // Enhanced parsing for multiple coordinate formats
    txt = txt.trim();
    
    // Handle formats like "41.73218° N, 111.83979° W" or "41.73218°N, 111.83979°W"
    const degreeMatch = txt.match(/(\d+\.?\d*)\s*°?\s*([NS])\s*,\s*(\d+\.?\d*)\s*°?\s*([EW])/i);
    if (degreeMatch) {
      let lat = parseFloat(degreeMatch[1]);
      let lon = parseFloat(degreeMatch[3]);
      
      // Convert S to negative latitude, W to negative longitude
      if (degreeMatch[2].toUpperCase() === 'S') lat = -lat;
      if (degreeMatch[4].toUpperCase() === 'W') lon = -lon;
      
      return { lat, lon };
    }
    
    // Handle simple decimal format like "41.73218, -111.83979"
    const decimalMatch = txt.match(/([-+]?\d+\.?\d*)\s*,\s*([-+]?\d+\.?\d*)/);
    if (decimalMatch) {
      return {
        lat: parseFloat(decimalMatch[1]),
        lon: parseFloat(decimalMatch[2])
      };
    }
    
    return null;
  }
  function xy2ll(xFt,yFt,lat0,lon0){const xM=xFt*FT2M,yM=yFt*FT2M;const dLat=yM/EARTH_R, dLon=xM/(EARTH_R*Math.cos(lat0*Math.PI/180));return{lat:lat0+dLat*180/Math.PI,lon:lon0+dLon*180/Math.PI};}

  refresh(false);
})();
</script>
</body>
</html>
