<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bounded Spiral Designer</title>
  <script src="https://cdn.plot.ly/plotly-2.24.2.min.js"></script>
  <style>
    :root{--bg:#0d0d0d;--surface:#161616;--accent:#0a84ff;--text:#eaeaea;--muted:#888;--grid:#222}
    *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif}
    body{margin:0;min-height:100vh;display:flex;flex-direction:column;background:var(--bg);color:var(--text)}
    header{padding:1.2rem 2rem;font-size:1.4rem;font-weight:600}
    main{flex:1;display:grid;grid-template-rows:1fr auto}
    #graph{width:100%;height:100%}
    #controls{background:var(--surface);padding:1rem 2rem;border-top:1px solid #222;display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:1.2rem 2rem}
    .control{display:flex;flex-direction:column;gap:.35rem}
    label{font-size:.9rem;font-weight:500;color:var(--muted)}
    input[type=range],input[type=text]{width:100%;}
    input[type=range]{-webkit-appearance:none;height:6px;border-radius:3px;background:#333}
    input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;border-radius:50%;background:var(--accent);cursor:pointer}
    input[type=text]{padding:.45rem .6rem;border-radius:6px;border:1px solid #333;background:#0f0f0f;color:var(--text)}
    .value-label{align-self:flex-end;font-size:.85rem}
    button{padding:.55rem 1.1rem;border:none;border-radius:6px;background:var(--accent);color:#fff;cursor:pointer;font-size:.85rem}
    button:disabled{background:#666;cursor:not-allowed}
    #btnRow{grid-column:1/-1;display:flex;gap:1rem;justify-content:center}
    .status{font-size:.8rem;color:var(--muted);text-align:center;margin-top:0.5rem}
    .error{color:#ff6b6b}
    .success{color:#51cf66}
  </style>
</head>
<body>
  <header>Bounded Spiral Designer</header>
  <main>
    <section id="graph"></section>
    <section id="controls">
      <div class="control"><label>Slices (360° / value)</label><input id="slices" type="range" min="1" max="10" value="6"><span class="value-label" id="sliceVal">6</span></div>
      <div class="control"><label>Outward bounces (N)</label><input id="bounces" type="range" min="1" max="30" value="6"><span class="value-label" id="bounceVal">6</span></div>
      <div class="control"><label>Start radius r₀ (ft)</label><input id="r0" type="range" min="0.1" max="300" value="1" step="0.1"><span class="value-label" id="r0Val">1 ft</span></div>
      <div class="control"><label>Hold radius r<sub>hold</sub> (ft)</label><input id="rHold" type="range" min="2" max="2000" value="50" step="1"><span class="value-label" id="rHoldVal">50 ft</span></div>
      <div class="control"><label style="display:flex;align-items:center;gap:0.5rem">Debug Mode <input type="checkbox" id="debugMode" style="margin:0"></label><span class="value-label" id="debugModeVal">Full Pattern</span></div>
      <div class="control" id="sliceAngleControl" style="display:none"><label>Slice Angle (°)</label><input id="sliceAngle" type="range" min="0" max="359" value="0" step="1"><span class="value-label" id="sliceAngleVal">0°</span></div>
      <div class="control" style="grid-column:1/-1"><label>Center (lat, lon)</label><input id="centerLL" type="text" placeholder="41.73218° N, 111.83979° W  or  41.73218, -111.83979"></div>
      <div id="btnRow">
        <button id="consoleBtn">Console Waypoints</button>
        <button id="csvBtn">Download CSV</button>
      </div>
      <div class="status" id="status">Ready</div>
    </section>
  </main>

<script>
(()=>{
  // Configuration
  const API_BASE = 'http://localhost:5001/api';
  
  // DOM elements
  const $=id=>document.getElementById(id);
  const sliceS=$('slices'), nS=$('bounces'), r0S=$('r0'), rhS=$('rHold');
  const lbl={sliceVal:$('sliceVal'),bounceVal:$('bounceVal'),r0Val:$('r0Val'),rHoldVal:$('rHoldVal')};
  const debugMode = $('debugMode'), sliceAngle = $('sliceAngle');
  const debugLbl = {debugModeVal: $('debugModeVal'), sliceAngleVal: $('sliceAngleVal')};
  const statusEl = $('status');
  
  // Event listeners for controls
  [sliceS,nS,r0S,rhS].forEach(el=>el.addEventListener('input',()=>refresh()));
  $('consoleBtn').addEventListener('click', getWaypoints);
  $('csvBtn').addEventListener('click', downloadCSV);
  
  // Debug mode controls
  debugMode.addEventListener('change', () => {
    const isDebug = debugMode.checked;
    $('sliceAngleControl').style.display = isDebug ? 'flex' : 'none';
    debugLbl.debugModeVal.textContent = isDebug ? 'Single Slice' : 'Full Pattern';
    refresh();
  });
  
  sliceAngle.addEventListener('input', () => {
    debugLbl.sliceAngleVal.textContent = `${sliceAngle.value}°`;
    refresh();
  });

  // Utility functions
  const setStatus = (msg, type = 'info') => {
    statusEl.textContent = msg;
    statusEl.className = `status ${type}`;
  };
  
  const setButtonsEnabled = (enabled) => {
    $('consoleBtn').disabled = !enabled;
    $('csvBtn').disabled = !enabled;
  };

  const params = () => ({
    slices: +sliceS.value,
    N: +nS.value,
    r0: +r0S.value,
    rHold: +rhS.value,
    debugMode: debugMode.checked,
    debugAngle: +sliceAngle.value
  });
  
  const updateLabels = () => {
    lbl.sliceVal.textContent = sliceS.value;
    lbl.bounceVal.textContent = nS.value;
    lbl.r0Val.textContent = `${r0S.value} ft`;
    lbl.rHoldVal.textContent = `${rhS.value} ft`;
  };

  // API functions
  async function apiCall(endpoint, data = null, options = {}) {
    try {
      const config = {
        method: data ? 'POST' : 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
        ...options
      };
      
      if (data) {
        config.body = JSON.stringify(data);
      }
      
      const response = await fetch(`${API_BASE}${endpoint}`, config);
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `HTTP ${response.status}`);
      }
      
      return response;
    } catch (error) {
      console.error(`API call failed: ${endpoint}`, error);
      setStatus(`Error: ${error.message}`, 'error');
      throw error;
    }
  }

  async function getSpiralData() {
    try {
      setStatus('Generating spiral...');
      const response = await apiCall('/spiral-data', params());
      const data = await response.json();
      return data;
    } catch (error) {
      setStatus('Failed to generate spiral', 'error');
      throw error;
    }
  }

  async function getWaypoints() {
    try {
      setStatus('Computing waypoints...');
      setButtonsEnabled(false);
      
      const response = await apiCall('/waypoints', params());
      const data = await response.json();
      
      console.log('Waypoints Data:', JSON.stringify(data, null, 2));
      setStatus(`Generated ${data.totalWaypoints} waypoints across ${data.sliceCount} slices`, 'success');
      
      // Refresh the display to show waypoints
      await draw(true);
    } catch (error) {
      setStatus('Failed to compute waypoints', 'error');
    } finally {
      setButtonsEnabled(true);
    }
  }

  async function downloadCSV() {
    try {
      const centerVal = $('centerLL').value.trim();
      if (!centerVal) {
        alert('Please enter center coordinates');
        return;
      }
      
      setStatus('Generating CSV...');
      setButtonsEnabled(false);
      
      const requestData = {
        ...params(),
        center: centerVal
      };
      
      const response = await apiCall('/csv', requestData);
      
      // Create blob and download
      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'litchi_spiral_mission.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
      
      setStatus('CSV downloaded successfully', 'success');
    } catch (error) {
      setStatus('Failed to generate CSV', 'error');
    } finally {
      setButtonsEnabled(true);
    }
  }

  async function draw(showWaypoints = false) {
    try {
      const spiralData = await getSpiralData();
      const traces = spiralData.traces || [];
      
      // Add waypoints if requested
      if (showWaypoints) {
        try {
          const waypointResponse = await apiCall('/waypoints', params());
          const waypointData = await waypointResponse.json();
          
          const p = params();
          if (p.debugMode) {
            // Debug mode: show waypoints for single slice
            if (waypointData.waypoints && waypointData.waypoints.length > 0) {
              const slice = waypointData.waypoints[0];
              traces.push({
                x: slice.map(w => w.x),
                y: slice.map(w => w.y),
                mode: 'markers',
                marker: {color: '#ff0080', size: 6},
                name: 'Waypoints'
              });
            }
          } else {
            // Full pattern: show all waypoints
            waypointData.waypoints.forEach((slice, k) => {
              const hue0 = 220, hue1 = 300;
              const hue = hue0 + (hue1 - hue0) * (k / (waypointData.waypoints.length - 1 || 1));
              traces.push({
                x: slice.map(w => w.x),
                y: slice.map(w => w.y),
                mode: 'markers',
                marker: {color: `hsl(${hue} 80% 55%)`, size: 4}
              });
            });
          }
        } catch (waypointError) {
          console.warn('Could not load waypoints for display:', waypointError);
        }
      }
      
      Plotly.newPlot('graph', traces, {
        margin: {t: 20, l: 20, r: 20, b: 20},
        paper_bgcolor: 'var(--bg)',
        plot_bgcolor: 'var(--bg)',
        showlegend: false,
        xaxis: {
          showgrid: true,
          gridcolor: 'var(--grid)',
          dtick: 2,
          showticklabels: false,
          zeroline: false,
          scaleanchor: 'y',
          scaleratio: 1
        },
        yaxis: {
          showgrid: true,
          gridcolor: 'var(--grid)',
          dtick: 2,
          showticklabels: false,
          zeroline: false
        }
      });
      
      if (!showWaypoints) {
        setStatus('Ready');
      }
    } catch (error) {
      console.error('Draw error:', error);
      setStatus('Failed to draw spiral', 'error');
    }
  }

  async function refresh() {
    updateLabels();
    await draw();
  }

  // Health check on startup
  async function checkHealth() {
    try {
      const response = await fetch(`${API_BASE}/health`);
      if (response.ok) {
        setStatus('Connected to Python backend', 'success');
        setTimeout(() => setStatus('Ready'), 2000);
      } else {
        throw new Error('Backend not responding');
      }
    } catch (error) {
      setStatus('Backend connection failed - Please start Python server', 'error');
    }
  }

  // Initialize
  updateLabels();
  checkHealth();
  refresh();
})();
</script>
</body>
</html>
